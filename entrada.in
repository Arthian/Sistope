Cola
de
prioridad
es
un
ejemplo
de
selección,
más
ordenación,
junto
con
búsqueda
constituyen
problemas
fundamentales
de
ciencia
de
la
computación.
A
continuación
veremos
ejemplos
de
búsqueda.
indices
invertidos:
Es
una
estructura
de
datos
muy
utilizada
en
motor
de
busqueda
para
la
web.
Aquél
problema
consite
en
construir
un
índice
sobre
un
conjunto
de
'M'
documentos
(en
este
caso
los
documentos
son
páginas
web,
archivos
pdf,
archivos
word,
etc).
La
estructura
de
datos
consite
en
una
tabla
que
contiene
todas
las
palabras
relevantes
encontradas
en
el
texto,
y
por
cada
palabra
se
forma
una
lista
de
pares
<idDoc,
freq>
Por
ejemplo:
doc1
contiene:
casa
gato
arbol
gato
casa
doc2
contiene:
arbol
casa
arbol
doc3
contiene:
casa
gato
gato
Para
estos
documentos
se
tiene
la
lista
invertida:
casa->(doc1,
2)(doc2,
1)(doc3,
1)
gato->(doc1,
2)(doc3,
2)
arbol->(doc1,
1)(doc2,
2)
Entonces
debido
a
una
consulta:
"casa
gato",
el
problema
de
la
busqueda
consiste
en
encontrar
los
documentos
que
contienen
ambas
palabras.
Lo
cual
se
puede
hacer
con
ayuda
del
índice,
obteniendo
primero
la
lista
invertida
para
"casa"
y
luego
la
consulta
para
"gato",
finalmente
se
calcula
la
intersección
entre
ambas
listas
para
obtener
ls
soluciones,
es
decir,
las
listas:
casa
->(doc1,
2)(doc3,
1)
gato
->(doc1,
2)(doc3,
2)
ahora
se
intersectan,
quedando
la
lista:
(doc1,
4)(doc3,
3)
Luego
se
utiliza
algún
método
de
ranking
para
que
utiliza
las
frecuencias
para
ordenas
los
documentos
de
las
listas
resultantes
de
mayor
frecuencia
a
menor
frecuencia.
De
las
lista
ordenada
se
escogen
los
mejores
'k'
documentos.
Suponemos
que
el
costo
del
ranking
es
proporcional
al
tamaño
de
la
intersección.
El
costo
de
la
búsqueda
secuencial
se
puede
calcular
de
la
siguiente
manera,
suponiendo
los
términos
T[i]
y
T[j]
con
largos
de
listas
L[i]
y
L[j]
respectivamente
y
largos
de
la
lista
intersección
I[i,j],
entonces
para
una
consulta
"T[i]T[j]"
el
costo
es:
Rank(I[i,j])
+
Intersección(l[i],
L[j])
=
O(I[i,j]
+
(L[i]
+
L[j]))
Notar
que
la
intersección
se
asume
que
la
intersección
tiene
costo
lineal
con
el
largo
de
las
listas
involucradas.
El
supuesto
aquí
es
que
las
listas
están
ordenadas
por
identificador
de
documento,
lo
cual
permite
realizar
la
intersección
de
las
dos
listas
utilizando
un
algoritmo
parecido
al
"merge"
de
dos
listas
ordenadas.
Cuando
las
listas
no
están
ordenadas,
esta
operación
tarda
orden
N²
sobre
el
largo
de
las
listas,
debido
a
que
por
cada
elemento
de
la
lista1,
es
necesario
buscar
ese
elemento
secuencialmente
en
la
lista2,
es
decir
el
costo
es:
O(L[i]*L[j])
Paralelización
de
índices
invertidos:
Estrategía
1:
INDEXACIÓN
LOCAL:
En
este
caso
los
'N'
documentos
se
distribuyen
en
los
'p'
procesadores...
,
luego
cada
procesador
construye
un
índice
invertido
con
sus
'N/P'
documentos
locales.
Para
resolver
una
consulta,
esta
se
envía
a
los
'P'
procesadores,
cada
procesador
obtiene
los
top-k
locales,
luego
envían
sus
resultados
a
la
máquina
que
inició
la
consulta,
la
cual
realiza
el
merge
de
los
resultados
obtenidos,
para
obtener
los
top-k
globales.
Notar
que
todo
es
similar
al
problema
de
las
colas
de
prioridad,
la
diferencia
es
que
cada
procesador
utiliza
en
forma
local
un
algoritmo
y
estructura
de
datos
diferente
(un
algoritmo
de
selección,
rank
y
estructura
de
datos
diferente).
Por
lo
tanto
se
aplica
el
mismo
tipo
de
análisis
de
costo
que
el
caso
de
las
colas
prioridad.
Estrategía
2:
INDEXACIÓN
GLOBAL:
En
el
caso
anterior
el
supuesto
inicial
es
que
los
documentos
están
distribuidos
en
los
'P'
procesadores,
ahora
vamos
a
suponer
para
la
indexación
global
de
que
los
términos
de
la
tabla
de
vocabularios
están
uniformemente
distribuidos
en
los
'P'
procesadores.
En
este
caso
cada
término
es
alojado
en
un
procesador,
junto
con
toda
su
lista
invertida,
es
decir,
una
lista
invertida
que
considera
los
'N'
documentos
de
la
colección.
Esto
es
similar
a
mover
todas
las
listas
de
indexación
local
para
ese
término
a
un
único
procesador.
En
el
caso
de
la
indexación
global,
cada
consulta
es
resuelta
de
forma
secuencial,
mientras
que
en
indexación
local
cada
consulta
es
resuelta
en
paralelo,
sin
embargo,
en
indexación
global
se
pueden
procesar
varias
consultas
simultaneamente
en
paralelo,
mientras
que
en
indexación
local
las
consultas
se
procesan
una
a
una,
donde
para
procesar
cada
consulta
se
utilizan
todos
los
procesadores
en
paralelo.
Cuando
se
trata
de
indexación
global,
cada
termino
tiene
su
lista
completa
en
un
procesador,
lo
cual
complica
los
métodos
en
que
es
necesario
realizar
intersecciones
de
listas
invertidas,
esto
porque
si
una
consulta
tiene
dos
términos
asignados
a
procesadores
distintos,
es
necesario
transmitir
la
lista
más
corta
al
otro
procesador,
lo
cual
involucra
un
costo
adicional
en
comunicación
PROBLEMA
DE
BUSQUEDA
N°
2:
Arreglos
de
sufijos
Es
una
estructura
de
datos
muy
utilizada
para
busqueda
de
patrones,
especialmente
en
secuencias
de
ADN.
Dado
un
arreglo
de
caracteres
de
tamaño
N,
el
problema
consiste
en
encontrar
todas
las
ocurrencias
de
un
substring
de
tamaño
N.
Definimos
un
sufijo
en
la
posición
i-esima
del
arreglo
de
caracteres
como
el
string
que
va
desde
la
posición
i,
hasta
la
posición
N
del
arreglo.
Ejemplo:
"Este
es
un
arreglo
de
caracteres"
N
=
33
(includo
el
caracter
señalizador
de
fin
de
string)
sufijo(39)
=
"teres"
sufijo(2)
=
"ste
es
un
ejemplo
de
arreglo
de
caracteres"
El
arreglo
de
sufijos
es
un
arreglo
de
enteros,
tal
que
cada
elemento
del
arreglo
es
la
posición
de
un
sufijo
en
orden
lexicográfico.
NOTA:
El
espacio
en
blanco
es
menor
que
'a',
'
'
=
32
en
ASCII,
'a'
=
62
"E
s
t
e
_
e
s
_
u
n
_
e
j
e
m
p
l
o
_
d
e
_
a
r
r
e
g
l
o
_
d
e
_
c
a
r
a
c
t
e
r
e
s
\0"
"1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44"
El
arreglo
de
sufijos
quedaría:
"22
33
19
30
11
5
8
37
35
23
34
38
20
31
21
32
4
26
12
14
...
"
Si
el
arreglo
de
sufijos
se
recorre
desde
el
primer
al
último
elemento,
lo
que
se
observa
es
una
secuencia
de
strings
ordenada
de
manera
lexicográfica.
Por
lo
tanto
para
poder
encontrar
cualquier
substring
de
largo
M
en
tiempo
O(M*log(N))
comparaciones,
se
puede
realizar
una
busqueda
binaria
sobre
el
arreglo
de
sufijos
Paralelización:
Estrategia
de
indexación
local.
El
arreglo
de
N
caracteres
de
distribuye
en
P
procesadores,
de
manera
que
los
primeros
N/P
caracteres
quedan
en
el
procesador1
y
así
sucesivamente.
Por
lo
tanto
el
substring
de
busqueda
se
envía
a
todos
los
procesadores
y
cada
procesador
busca
en
forma
local.
Para
esto
cada
procesador
previamente
construyó
un
arreglo
de
sufijos
con
los
N/P
caracteres
asignados
al
procesador.
Esto
requieres
que
cada
procesador
copie
los
primeros
'm'
caracteres
de
su
vecino.
Esto
para
poder
construir
un
arreglo
de
sufijos
local
que
permita
realizar
busquedas
sin
ambigüedad
en
cada
procesador.
Paralelización
N°2:
Estrategia
de
indexación
global.
Primero
se
construye
un
arreglo
de
sufijos
considerando
los
N
caracteres
del
texto.
Luego
este
arreglo
global
se
distribuye
en
los
procesadores
de
manera
que
los
primeros
N/P
elementos
quedan
en
el
procesador1
y
así
sucesivamente.
El
arreglo
de
N
caracteres
del
texto
tambíen
está
distribuido
como
indexación
local,
sin
embargo,
en
este
caso
un
elemento
del
arreglo
de
sufijos
puede
indicar
una
posición
de
texto
ubicado
en
otro
procesador,
es
decir,
los
elementos
del
arreglo
no
necesariamente
son
punteros
locales
como
en
el
caso
de
indexación
local
Una
solución
al
problema
de
los
punteros
remotos
es
que
por
cada
elemento
del
arreglo
de
sufijos
global,
es
mantener
algunos
caracteres
(
c
caracteres)
conteniendo
los
primeros
caracteres
del
sufijo
correspondiente,
de
tal
manera
que
comparando
las
consultas
(q
string)
con
estos
caracteres,
reduzca
significativamente
la
cantidad
de
mensajes
enviados.
La
idea
es
que
estos
c
caracteres
sirvan
para
definir
si
la
busqueda
continua
a
la
mitad
izquierda
o
la
derecha
para
un
gran
número
de
consultas.
Solo
en
el
caso
en
que
los
c
caracteres
son
idénticos
a
los
primeros
c
caracteres
de
la
consulta
se
recurre
al
envío
de
un
mensaje
al
procesador
respectivo
para
solicitar
más
caracteres
del
sufijo
ejemplo:
con
c=2
y
m=4
h
a
g
a
_
s
u
_
p
r
o
p
i
o
_
e
j
e
m
p
l
o
$
<-Caracteres
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
<-Índices
Arreglo
de
sufijos
resultante
(más
abajo
se
ponen
los
c
arreglos
que
mantienen
los
primeros
caracteres
del
arreglo
de
sufijos):
15
8
5
4
2
16
18
3
1
13
17
21
19
14
11
22
12
20
9
10
6
7
23
<-Arreglo
de
sufijos
_
_
_
a
a
e
e
g
h
i
j
l
m
o
o
o
p
p
p
r
s
u
$
<-Primer
arreglo
e
p
s
_
g
j
m
a
a
o
e
o
p
_
p
$
i
l
r
o
u
_
$
<-Segundo
arreglo
En
el
caso
de
construir
los
arreglos
de
sufijos
locales
entre
2
procesadores
quedaría:
h
a
g
a
_
s
u
_
p
r
o
pio_
p
i
o
_
e
j
e
m
p
l
o
$
<-Caracteres
locales
1
2
3
4
5
6
7
8
9
10
11
1
2
3
4
5
6
7
8
9
10
11
<-Indices
locales
Arreglo
de
sufijos
con
c
arreglos
extra:
8
5
4
2
3
1
11
9
10
6
7
4
5
7
2
6
10
8
3
11
1
9
<-Arreglos
de
sufijos
locales
_
_
a
a
g
h
o
p
r
s
u
_
e
e
i
j
l
m
o
o
p
p
<-Primer
arreglo
p
s
_
g
a
a
p
r
o
u
_
e
j
j
o
e
o
p
_
$
i
l
<-Segundo
arreglo
Si
queremos
saber
la
consulta
"prop"
está
en
el
texto:
Con
arreglos
locales
<Hacer
ejemplo
de
busqueda>
El
costo
para
las
q*p
consultas
sería:
costo
de
índice
local
=
q*p*(alpha
+log(n/p))
+
q*p*G
+
L
Donde
"alpha"
es
una
constante
del
costo
de
iniciación
de
la
búsqueda.
costo
de
índice
global:
Una
desventaja
del
arreglo
de
índice
global
es
que
si
muchas
consultas
se
repiten,
se
produce
el
desbalance
de
carga,
dado
que
unos
pocos
procesadores
tienden
a
recibir
la
mayoría
de
las
consultas.
Esto
hace
que
el
rendimiento
se
degrade
significativamente.
A
continuación
veremos
una
solución
al
problema,
en
la
cual,
cualquier
consulta
puede
ser
enviada
a
cualquier
procesador
y
posteriormente
se
realiza
una
busqueda
entre
procesadores
en
Log(p)
pasos.
La
estrategía
consiste
en
distribuir
circularmente
entre
los
procesadores
los
elementos
del
arreglo
global
tal
que
el
elemento
i-esimo
del
arreglo
quede
ubicado
en
el
procesador
(i%p)+1,
esto
suponiendo
que
el
primer
elemento
del
arreglo
tiene
subindice
1.
ejemplo:
con
c=2
y
m=4
h
a
g
a
_
s
u
_
p
r
o
p
i
o
_
e
j
e
m
p
l
o
$
<-Caracteres
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
<-Índices
Arreglo
de
sufijos
resultante
(más
abajo
se
ponen
los
c
arreglos
que
mantienen
los
primeros
caracteres
del
arreglo
de
sufijos):
15
8
5
4
2
16
18
3
1
13
17
21
19
14
11
22
12
20
9
10
6
7
23
<-Arreglo
de
sufijos
0
1
2
3
0
1
2
3
0
1
2
3
0
1
2
3
0
1
2
3
0
1
2
<-id
del
procesador
asignado
Procesador
0:
15
2
1
19
12
6
_
a
h
m
p
s
e
g
a
p
i
u
Procesador
1:
8
16
13
14
20
7
_
e
i
o
p
u
p
j
o
_
l
_
Procesador
2:
5
18
17
11
9
23
_
e
j
o
p
$
s
m
e
p
r
$
Procesador
3:
4
3
21
22
10
a
g
l
o
r
_
a
o
$
o
Ejemplo,
buscar
"opio"
Se
hace
busqueda
binaria
en
el
primer
procesador
y
se
encuentra
que
"op"
está
entre
"mp"
y
"pi",
es
decir
entre
la
cuarta
y
quinta
columna
(solo
en
la
4°
columna
está
lo
que
se
busca)
(costo
Log(N/p)
).
Luego
se
hace
busqueda
binaria
entre
las
filas
de
la
cuarta
columna
(costo
Log(P)
).
Costo
BSP:
Log(N/P)
+
Log(P)*(1+G+L)
En
esta
estrategía,
cualquier
búsqueda
puede
comenzar
en
cualquier
procesador
y
por
lo
tanto
el
balance
de
carga
proviene
de
distribuir
uniformemente
las
consultas
en
los
procesadores.
En
la
práctica,
esta
estrategía
es
mucho
más
eficiente
que
las
otras
dos
anteriores
(global
y
local).
Entidad
1.
Queremos
saber
de
quien
es
la
mochila
Tabla
1:
personas
-nombre
-rut
-direccion
-telefono
Tabla
2:
mochila
-capacidad
-marca
-dueño
(relación
con
persona)
-contiene(relación
con
articulos)
Tabla
3:
articulos
-codigo
articulo
-Nombre
articulo
Tabla
4:
Contiene
-codigo
articulo
-codigo
mochila
-cantidad
Tabla
5:
pertenece
-rut
-codigo
mochila
La
paralelización
de
la
base
de
datos
consiste
en
mantener
en
cada
procesador
el
mismo
esquema
de
tabla,
es
decir...
y
distribuir
uniformemente
las
tuplas
de
las
tablas
en
cada
procesador.
Para
distribuir
las
tuplas
se
puede
usar
la
regla:
llave%p
=
id_procesador
Donde
llave
puede
ser
rut,
codigoMochila,
codigoArticulo
Donde
la
precedencia
puede
ser
rut>codigoMochila>codigoArticulo
Se
pide
resolver
las
siguientes
consultas
en
paralelo
y
formular
su
costo
BSP.
-"personas
que
tienen
lápices
en
su
mochila"
-"personas
con
el
mismo
contenido
en
la
mochila"
Para
la
primera
consulta:
T1:
pi(
Sigma(articulos)
)
codArticulo
nombre="lapiz"
T2:
pi(
Sigma(contiene
X
T1))
codMochila
T1.codArticulo
=
contiene.codArticulo
T3:
pi(Sigma(pertenece
X
T2))
rut
pertenece.codMochila
=
T2.codMochila
BSP.
-Se
hace
un
broadcast
"lapiz",
costo
O(P*G+L)
-En
paralelo
calcular
T1,
costo
O(|articulos|/P)
La
mochila
como
tiene
mayor
procedencia,
entonces
las
mochilas
estna
distribuidas
uniformemente
if
(T1!=0)
broadcast(T1),
costo
O(p*G+L)
sync();
En
paralelo
se
calcula
T2,
costo
O(|contiene|/"*
|T1|)
if
(|T2|
!=
0)
broadcast(T2)
//Cada
procesador
envía
su
tabla
T2
a
todas
las
máquinas
costo
O(P*|T2|*G
+
L
En
paralelo
cada
procesador
calcula
T3
y
print
Costo
O(|pertenece|/P
x
|T2|)
y
O(|personas|/p
x
|T3|)
Problema
BD:
Cada
procesador
tiene
tabla
S
en
que
las
tuplas
se
reparten
con
"primary
key
%p
=
pid"
Las
tablas
son:
*persona(rut,
nombres,
apellidos,
sueldo)
*productos(prodId,
nombre,
valorNeto)
*stock(prodId,
Stock)
*empresa(empresaId,
nombre,
direccion)
*ventas(facturaId,
empresaId,
prodId,
rut,
cantidad,
valor)
Preguntas:
(estudiar
el
join,
immer-join
1)
La
empresa
que
más
a
comprado:
-Agrupar
tuplas
(empresaId,
prodId,
cantidad)
-Repartir
tuplas
por
"prodId"
-Calcular
valores
por
cada
tupla
enviada
-sumar
por
empresa
-repartir
tuplas
por
"empresaId"
-Buscar
máximo
local
-buscar
máximo
global
2)
Listado
de
productos
y
stock
3)
El
nombre
de
la
persona
que
más
ha
vendido
4)
